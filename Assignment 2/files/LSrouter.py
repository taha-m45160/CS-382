import sys
from dijkstar import Graph, find_path
from collections import defaultdict
from router import Router
from packet import Packet
import json



class LSrouter(Router):
    """Link state routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0
        self.seqNo = 0
        self.linkStates = {} # link states of all routers in the network
        self.myState = {}  # broadcasted to other routers in json format
        self.myNetwork = Graph(undirected = True)  # provides global view of network
        self.fwdTable = {}  # created based on network graph
        self.trackSeqNo = {}  # tracks version updates for all nodes in network


    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""
        if packet.isTraceroute():
            # Hints: this is a normal data packet
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            #print(packet.srcAddr, "to", packet.dstAddr, "via", self.addr, self.fwdTable)

            if packet.dstAddr in self.fwdTable:
                self.send(self.fwdTable[packet.dstAddr], packet)

            else:
                #print(packet.srcAddr, "to", packet.dstAddr, "via", self.addr, self.fwdTable)
                pass

            

        else:
            # Hints: this is a routing packet generated by your routing protocol
            # check the sequence number 
            # if the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            
            state = json.loads(packet.content)

            seqNo = state["seqNo"]
            
            del state["seqNo"]

            # source address of routing packet
            endpoint = packet.srcAddr

            if state not in self.linkStates:
                self.linkStates[packet.srcAddr] = state

            else:
                # update the forwarding table
                for node, cost in state.items():
                    if node not in self.fwdTable:
                        self.fwdTable[node] = node
                        self.myNetwork.add_edge(endpoint, node, cost)

                self.runDijkstar()

                # broadcast the packet to other neighbors
                self.broadcastState()
            

    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""

        # update link state version
        self.seqNo += 1

        # update link state
        self.myState[endpoint] = cost

        # update network graph
        self.myNetwork.add_edge(self.addr, endpoint, cost)

        # update the forwarding table
        self.updateFwdTable(endpoint, port)

        # broadcast the new link state of this router to all neighbors
        self.broadcastState()


    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        
        # update link state
        self.seqNo += 1

        # update link state
        endpoint = self.getKey(self.fwdTable, port)
        del self.fwdTable[endpoint]

        # update network graph
        self.myNetwork.remove_edge(self.addr, endpoint)

        # update the forwarding table
        self.updateFwdTable(endpoint, port, True)

        # broadcast the new link state of this router to all neighbors
        self.broadcastState()


    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs
            
            # broadcast the link state of this router to all neighbors
            self.broadcastState()


    def debugString(self):
        """TODO: generate a string for debugging in network visualizer"""
        return ""


    def updateFwdTable(self, endpoint, port, remove = False):
        """
        updates the forwarding table by including 
        a newly added link or removing a 
        recently deleted link and then runs dijkstar
        to update the paths of rest of the nodes
        in the network
        """
        if not remove:
            # add new link entry
            self.fwdTable[endpoint] = port
            self.trackSeqNo[endpoint] = 0
        
        else:
            # remove link entry
            del self.fwdTable[endpoint]
            del seld.trackSeqNo[endpoint]

        self.runDijkstar()

        return


    def broadcastState(self):
        state = self.myState
        state["seqNo"] = self.seqNo
        state = json.dumps(state)
        
        for node, port in self.fwdTable.items():
            if node is not self.addr:
                self.send(port, Packet(2, self.addr, node, state))

        return


    def runDijkstar(self):
        """
        updates paths of the nodes that
        are not the immediate neighbors 
        of the concerned router
        """

        # update ports of all other nodes
        for node, port in self.fwdTable.items():
            if node not in self.myState.keys() and node is not self.addr:
                pathInfo = find_path(self.myNetwork, self.addr, node)
                #print(self.addr, node, pathInfo)
                self.fwdTable[node] = self.myState[pathInfo.nodes[1]]    
        
        return


    def getKey(self, dict, val):
        """
        returns the key in a
        dictionary given the value
        against that key
        """

        for k, v in dict.items():
            if v == val:
                return k
        
        else:
            return None