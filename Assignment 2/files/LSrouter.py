import sys
from dijkstar import Graph, find_path
from collections import defaultdict
from router import Router
from packet import Packet
import json



class LSrouter(Router):
    """Link state routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0
        self.seqNo = 0
        self.linkState = {}  # broadcasted to other routers in json format
        self.myNetwork = Graph(undirected = True)  # provides global view of network
        self.fwdTable = {}  # created based network graph
        self.trackSeq = {}  #

    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""
        if packet.isTraceroute():
            # Hints: this is a normal data packet
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dstAddr in self.fwdTable:
                self.send(self.fwdTable[packet.dstAddr], packet)

            else:
                pass

        else:
            # Hints: this is a routing packet generated by your routing protocol
            # check the sequence number 
            # if the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            state = json.loads(packet)

            state = state.split(" ")


    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""

        # update link state
        self.linkState[endpoint] = cost

        # update network graph
        self.myNetwork.add_edge(self.addr, endpoint, cost)

        # update the forwarding table
        self.updateFwdTable(endpoint, port)

        # broadcast the new link state of this router to all neighbors
        self.broadcastState()


    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        
        # update link state
        endpoint = self.getVal(self.fwdTable, port)
        del self.fwdTable[endpoint]

        # update network graph
        self.myNetwork.remove_edge(self.addr, endpoint)

        # update the forwarding table
        self.updateFwdTable(endpoint, port, True)

        # broadcast the new link state of this router to all neighbors
        self.broadcastState()


    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs
            # Hints:
            # broadcast the link state of this router to all neighbors
            self.broadcastState()


    def debugString(self):
        """TODO: generate a string for debugging in network visualizer"""
        return ""


    def updateFwdTable(self, endpoint, port, remove = False):
        if not remove:
            # add new link entry
            self.fwdTable[endpoint] = port
        
        else:
            # remove link entry
            del self.fwdTable[endpoint]

        self.runDijkstar()

        return


    def broadcastState(self):
        self.seqNo += 1
        state = str(self.seqNo) + " " + json.dumps(self.linkState)  
        print(state)
        for node, port in self.fwdTable.items():
            print(node, " ", port)
            self.send(port, Packet(2, self.addr, node, state))

        return


    def runDijkstar(self):
        # update ports of all other nodes
        for node, port in self.fwdTable.items():
            pathInfo = find_path(self.myNetwork, self.addr, node)
            
            if port == pathInfo.nodes[0]:
                continue

            else:
                self.fwdTable[node] = pathInfo.nodes[1]
        
        return


    def getVal(self, dict, val):
        for k, v in dict.items():
            if v == value:
                return key
        
        else:
            return None